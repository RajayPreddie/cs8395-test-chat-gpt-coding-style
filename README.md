# cs8395-test-chat-gpt-coding-style

# ChatGPT Coding Style Testing Framework

## Introduction

Welcome to the ChatGPT Coding Style Testing Framework! This innovative tool is designed to assess the coding style and quality of Python code generated by ChatGPT. By leveraging a dynamic prompt system based on a diverse set of Python-related keywords and analyzing the results with tools like flake8, pylint, and Black, this framework provides comprehensive insights into ChatGPT's adherence to Python coding standards.

## Why Is This Testing Framework Important?

In the evolving landscape of AI-generated code, maintaining high standards of code quality and style consistency is crucial. This framework sets a benchmark for assessing the proficiency of ChatGPT in handling a wide range of Python programming tasks, from simple to complex. It serves as an essential tool for ensuring that AI-generated code is readable, maintainable, and adheres to established best practices.

## Usage

1. **Installation**:
   - Ensure flake8, pylint, and Black are installed.
2. **Running the Framework**:
   - Run the script: `python main.py --generate_responses`.
   - The `--generate_responses` option generates ChatGPT responses. Without responses in the `gpt_responses` folder, the script will prompt ChatGPT regardless of options.

## Understanding the Results

The framework outputs comprehensive JSON results for each linter (flake8, pylint, black), along with an `output` key for integration with external test suites.


### Detailed JSON Output Examples

#### Flake8 Results

```json
{
    "overall": {
            "total_violations": 644,
            "average_violations_per_line": 0.4821317245515588,
            "average_violations_per_file": 6.44,
            "violation_frequencies": {
                "W291 trailing whitespace": 158,
                "E302 expected 2 blank lines, found 1": 51,
                "W191 indentation contains tabs": 20,
                "E305 expected 2 blank lines after class or function definition, found 1": 48,
                "W292 no newline at end of file": 100,
                "E111 indentation is not a multiple of 4": 70,
                "F401 'django' imported but unused": 1,
                "E501 line too long (80 > 79 characters)": 3,
                "E114 indentation is not a multiple of 4 (comment)": 26,
                ...
            }

            "most_frequent_violation": {
                "frequency": 158,
                "violation_type": "W291 trailing whitespace"
            },
            "top_violations": [
                [
                    "W291 trailing whitespace",
                    158
                ],
                [
                    "W292 no newline at end of file",
                    100
                ],
                [
                    "E111 indentation is not a multiple of 4",
                    70
                ]
            ]
        },
        "by_tag": {
            "DependencyInjection": {
                "total_violations": 36,
                "average_violations_per_line": 0.015,
                "average_violations_per_file": 0.36,
                "violation_frequencies": {
                    "W291 trailing whitespace": 23,
                    ...
                }
                ...
            }
    }
}

```

#### Pylint Results

```json
{
  "overall": {
            "total_violations": 734,
            "average_violations_per_line": 0.5623883125131359,
            "average_violations_per_file": 7.34,
            "violation_frequencies": {
                "Trailing whitespace (trailing-whitespace)": 175,
                "Bad indentation. Found 1 spaces, expected 4 (bad-indentation)": 13,
                "Bad indentation. Found 2 spaces, expected 8 (bad-indentation)": 7,
                "Final newline missing (missing-final-newline)": 100,
                ...
            }
            ...
                 "most_frequent_violation": {
                "frequency": 175,
                "violation_type": "Trailing whitespace (trailing-whitespace)"
            },
            "top_violations": [
                [
                    "Trailing whitespace (trailing-whitespace)",
                    175
                ],
                [
                    "Final newline missing (missing-final-newline)",
                    100
                ],
                [
                    "Missing module docstring (missing-module-docstring)",
                    100
                ]
            ]
        },
        "by_tag": {
            "DependencyInjection": {
                "total_violations": 41,
                "average_violations_per_line": 0.017083333333333332,
                "average_violations_per_file": 0.41,
                "violation_frequencies": {
                    "Trailing whitespace (trailing-whitespace)": 23,
                    ...
                }
                ...
            }


}
```

#### Black Results

```json
{
   "overall": {
            "total_violations": 100,
            "average_violations_per_line": null,
            "average_violations_per_file": 1.0,
            "violation_frequencies": {
                "Non-compliant": 100
            },
            "most_frequent_violation": {
                "frequency": 100,
                "violation_type": "Non-compliant"
            },
            "top_violations": [
                [
                    "Non-compliant",
                    100
                ]
            ]
        },
        "by_tag": {
            "DependencyInjection": {
                "total_violations": 1,
                "average_violations_per_line": null,
                "average_violations_per_file": 0.01,
                "violation_frequencies": {
                    "Non-compliant": 1
                },
                ...
            }
            ...
        }

}
```

#### Output for Integration

```json
{
    "output": 4.926666666666667
}

```

This output key is crucial for integration with the [cs8395/test-suite framework](https://github.com/nkalupahana/cs8395-test-suite), facilitating standardized code quality evaluation.

### Comprehensive Analysis of Coding Ability

- **Flake8, Pylint, and Black**: Each tool provides unique insights into coding style, quality, and formatting. The combination of these results offers a multi-faceted view of ChatGPT's coding abilities.
- **Overall and Tag-specific Results**: Reflect ChatGPT's consistency and adaptability in coding standards across different levels of complexity.
- **Integration Output**: The average violations per file across linters is a key metric for broader evaluations, facilitating comparisons and benchmarking within larger testing frameworks.

## Prompt Description

Prompts for ChatGPT are generated using predefined Python-related keywords. The complexity varies based on the number of keywords:

- **Easy**: One keyword.
- **Medium**: Two keywords.
- **Hard**: Three keywords.

### Example Keywords

- Basic: `list`, `dict`, `set`
- Advanced: `asyncio`, `Coroutine`, `Metaclass`
- Libraries and Tools: `numpy`, `flask`, `tensorflow`

### Prompt

```python
chatgpt_prompt = f"Act as a Python developer and create a Python program. Here are the specifications for the Python program. Use the following keyword(s) in the following list as a start to create an idea for a problem that you would like to solve using python: {','.join(problem_description['keywords'])}. In addition, only return the raw code for the Python program. To ensure that the Python program is valid, act as Command Line Interface (you do not need to execute code) and make sure that the program runs correctly. Generate code for a functional python program as described above.
```

## Additional Information

### Installation Guide
To install the required linters, run the following commands:
```bash
pip install flake8 pylint black
```

### Using the --generate_responses Option
The `--generate_responses` option triggers the generation of ChatGPT responses. If the `gpt_responses` folder is empty, the script will automatically prompt ChatGPT to generate new responses.

### Metrics Analyzed by Each Linter
- **Flake8**: Analyzes code for errors, style issues, and complexity.
- **Pylint**: Focuses on code quality, looking for programming errors, helps enforce a coding standard and sniffs for code smells.
- **Black**: A formatter that reformats the entire file in place, ensuring code adheres to its style guide.

### Difficulty Levels
The difficulty levels (easy, medium, hard) are determined based on the number of keywords used in the ChatGPT prompts:
- **Easy**: Uses one keyword.
- **Medium**: Uses two keywords.
- **Hard**: Uses three keywords.

### Contributing
Contributions to the framework are welcome. You can contribute by submitting pull requests, reporting bugs, or suggesting enhancements.

## Detailed Explanation of Results

### Linters and Their Specific Roles
- **Flake8**: Focuses on PEP 8 style guidelines, checking for issues like spacing, line length, and other stylistic inconsistencies.
- **Pylint**: Provides a deeper analysis beyond style, looking at errors, code smells, and potential refactorings for improved code quality.
- **Black**: Concentrates on code formatting, automatically reformats the code to conform to its style guide, ensuring consistency.

### Overall Results
The overall results offer a summary of the code quality analyzed by the framework. They include metrics such as total violations and average violations per line or file, providing a snapshot of coding style adherence across all linters.

### Results by Tags: Easy, Medium, Hard
These tags reflect the complexity of the tasks based on the number of keywords used. The framework evaluates how the complexity influences coding style and quality, with 'easy' involving basic Python concepts and 'hard' incorporating more complex programming constructs.

### Output Key for External Integration
The `output` key, showing the average of violations per file across all linters, is crucial for integration with external test suites like cs8395/test-suite. It provides a standardized metric for broader evaluations within the Python development community.
